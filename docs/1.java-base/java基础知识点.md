# 前言
本节内容
1. Java基础
   1. JVM,JDK,JRE,字节码，Java基本数据类型，装箱+拆箱，变量，位运算
   2. 面向对象，构造方法，接口，抽象类，String，Object
   3. Java异常，泛型，放射，IO，注解
2. Java基础常见面试题+知识点


# 一、Java基础

## part 1

### JDK
JDK 的英文全称是 Java Development Kit。JDK是用于制作程序和Java应用程序的<font color="red">软件开发环境</font>。Java 开发人员可以在 Windows、macOS、Solaris 和 Linux 上使用，是一个跨平台编程语言。JDK 帮助他们编写和运行 Java 程序。可以在同一台计算机上安装多个 JDK 版本。

### JRE
JRE 的英文全称是 Java Runtime Environment。JRE 是一个旨在运行其他软件的软件(有点绕口)。它包含类库、加载器类和 JVM。简单来说，如果你想运行 Java 程序，你需要 JRE。如果您不是程序员，则无需安装 JDK，只需安装 JRE 即可运行 Java 程序。不过，所有 JDK 版本都与 Java Runtime Environment 捆绑在一起，因此无需在 PC 单独下载和安装 JRE。JRE 的完整形式是 Java <font color="red">运行时环境</font>。

### 字节码
在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。
![](./img/2023-02-27-10-31-57.png)



### 位运算

Java 中有三种移位运算符：

- <font color ="red"><<</font> :左移运算符，向左移若干位，高位丢弃，低位补零。x << 1,<font color ="red">相当于 x 乘以 2</font>(不溢出的情况下)。
- <font color ="red">>></font>:带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x >> 1,<font color ="red">相当于 x 除以 2</font>。
- <font color ="red">>>></font> :无符号右移，忽略符号位，空位都以 0 补齐。

Java中位运算和普通运算的效率差别
```java 
public class Test10 {
    public static void main(String[] args) {
        long a=101;
        long b=1000000;
//        位运算方法
        long l1 = System.currentTimeMillis();
        for (int i = 0; i < b; i++) {
            a=a<<2;
        }
        long l2 = System.currentTimeMillis();
        System.out.println("位运算花费的时间为："+(l2-l1));
 
//        普通运算方法
        long l3 = System.currentTimeMillis();
        for (int i = 0; i < b; i++) {
            a=a*2*2;
        }
        long l4 = System.currentTimeMillis();
        System.out.println("普通运算花费的时间为："+(l4-l3));
    }
}
```
结论如下：

1、当 b=1000000级（百万级），及以下时，位运算的效率没有普通运算的效率高。

位运算花费的时间为：3
普通运算花费的时间为：2

2、当 b=10000000级（千万级）时，位运算的效率会比普通运算的效率略高。

位运算花费的时间为：6
普通运算花费的时间为：7

3、当 b=100000000级（亿级）时，位运算的效率会比普通运算的效率高。

位运算花费的时间为：43
普通运算花费的时间为：60

4、当 b=1000000000级（十亿级）时，位运算的效率会明显比普通运算的效率高。

所以在我们日常中确实普通运算的效率是足够了，但是作为一个优秀的程序员当我们处理大数据量的时候，当然还是需要学会使用位运算。

位运算花费的时间为：382
普通运算花费的时间为：558
![](./img/2023-02-27-10-48-57.png)


### 变量
#### 成员变量与局部变量的区别？
- 语法形式 ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。
- 存储方式 ：从变量在内存中的存储方式来看,如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。**而对象存在于堆内存，局部变量则存在于栈内存。**
- 生存时间 ：从变量在内存中的生存时间上看，成员变量是对象的一部分，**它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。**
- 默认值 ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。
  
- **静态变量**有什么作用？
静态变量可以被类的所有实例共享。**无论一个类创建了多少个对象，它们都共享同一份静态变量。**

通常情况下，静态变量会被 final 关键字修饰成为常量。

字符型常量和字符串常量的区别?
形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。
含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。
占内存大小 ： 字符常量只占 2 个字节; 字符串常量占若干个字节。
(注意： char 在 Java 中占两个字节)

---

- 静态方法为什么不能调用非静态成员?
这个需要结合 JVM 的相关知识，主要原因如下：

>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。
静态方法和实例方法有何不同？

- 1、调用方式

在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象 。

不过，需要注意的是一般不建议使用 对象.方法名 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。

因此，一般建议使用 类名.方法名 的方式来调用静态方法。


- 2、访问类成员是否存在限制

静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。


### 基本数据类型
![](./img/2023-02-27-11-20-50.png)

>注意：
Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析。
char a = 'h'char :***单引号***，String a = "hello" :***双引号。***
这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean 。

### 装箱+拆箱
一. 基本类型和包装类型的区别？
- 成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。
- 包装类型可用于泛型，而基本类型不可以。
- 基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。
- 相比于对象类型， 基本数据类型占用的空间非常小。



2. 包装类型的缓存机制了解么？
Java 基本数据类型的包装类型的大部分都用到了**缓存机制来提升性能**。

Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。

常见的面试题，看返回结果
```java
   public static void main(String[] args) {
        System.out.println("(Integer)129 == (Integer)129");
        System.out.println( (Integer)129 == (Integer)129);
        System.out.println("(Integer)127 == (Integer)127");
        System.out.println((Integer)127 == (Integer)127);
    }


>>>>>>返回结果 
(Integer)129 == (Integer)129
false
(Integer)127 == (Integer)127
true
```
> 上述原因
> 如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。==在对象中比较的是内存地址，所以false
>

---

```java
Integer i1 = 40;
Integer i2 = new Integer(40); // 主要原因是装箱了也是一个新地址
System.out.println(i1==i2);

同样返回false
```

究其原因：
1：==比的是内存地址
2：包装类型的装箱和拆箱

![](./img/2023-02-27-11-51-51.png)


二. 自动装箱与拆箱了解吗？原理是什么？
什么是自动拆装箱？

装箱：将基本类型用它们对应的引用类型包装起来；
拆箱：将包装类型转换为基本数据类型；
```java
Integer i = 10;  //装箱
int n = i;   //拆箱

```
**注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。**

### JVM



## part2
### 面向对象 

### 构造方法

### 接口

### 抽象类

### String

### Object



## part3

### Java异常 
### 泛型 
### 放射 
### IO 
### 注解
